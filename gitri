#!/usr/bin/python
import os
import sys
import getopt
import xml.dom.minidom

import git

def main():
	if (len(sys.argv) < 2) or not gitri_commands.has_key(sys.argv[1]):
		#TODO: write usage
		print 'gitri usage'
	else:
		cmd = gitri_commands[sys.argv[1]]
		[optlist, args] = getopt.gnu_getopt(sys.argv[2:], cmd[2])
		if cmd[1]:
			cmd[0](Project.find_project(), optlist, *args)
		else:
			cmd[0](optlist, *args)

class GitriError(StandardError):
	pass

class InvalidProjectError(GitriError):
	pass

GITRI_DIR = '.gitri'

class Project(object):
	def __init__(self, dir):
		self.dir = os.path.abspath(dir)
		if not self.valid_project(self.dir):
			raise InvalidProjectError('not a valid gitri project')

		self.gitri_dir = os.path.join(self.dir, GITRI_DIR)
		manifest_dir = os.path.join(self.gitri_dir, 'manifest')
		if git.Repo.valid_repo(manifest_dir):
			self.manifest_repo = git.Repo(manifest_dir)
		else:
			self.manifest_repo = None

		self.remotes = {}
		self.repos = []
		self.default = {}

		manifest = xml.dom.minidom.parse(os.path.join(manifest_dir, 'manifest.xml'))
		m = manifest.childNodes[0]
		if m.localName != 'manifest':
			raise GitriError('malformed manifext.xml: no manifest element')
		for node in m.childNodes:
			if node.localName == 'default':
				self.default.update(dict(node.attributes.items()))
			elif node.localName == 'remote':
				remote = dict(node.attributes.items())
				#TODO: detect duplicates
				self.remotes[remote['name']] = remote
			elif (node.localName == 'project') or (node.localName == 'repo'):
				repo = {}
				repo.update(self.default)
				repo.update(dict(node.attributes.items()))
				#TODO: detect duplicates
				self.repos.append(repo)

	@classmethod
	def find_project(cls, dir = None):
		if dir == None:
			dir = os.getcwd()

		head = dir
		while head:
			try:
				return cls(head)
			except InvalidProjectError:
				if head == '/':
					head = None
				else:
					(head, tail) = os.path.split(head)

		raise InvalidProjectError('not a valid gitri project')

	@classmethod
	def init(cls, optlist, url, dir=None, revset=None):
		optdict = {}
		optdict.update(optlist)

		if dir == None:
			#TODO: come up with a better default name, if possible
			dir = os.path.splitext(os.path.basename(url))[0]
		dir = os.path.abspath(dir)

		if os.path.exists(dir):
			raise GitriError('Directory already exists')

		remote = optdict.get('-o', 'origin')
		git.Repo.clone(url, dir=os.path.join(dir, GITRI_DIR, 'manifest'), rev=revset, remote=remote)

		manifest_src = os.path.join(dir, GITRI_DIR, 'manifest', 'manifest.xml')
		if not os.path.exists(manifest_src):
			raise GitriError('invalid manifest repo: no manifest.xml')

		#origin_file = open(os.path.join(dir, GITRI_DIR, 'ORIGIN'), 'w')
		#origin_file.write(remote)
		#origin_file.close()

		p = cls(dir)
		p.update()

	@classmethod
	def valid_project(cls, dir):
		return os.path.exists(os.path.join(dir, GITRI_DIR, 'manifest', 'manifest.xml'))

	def revset(self):
		return self.manifest_repo.head()

	#def origin(self):
	#	origin_file = open(os.path.join(self.dir, GITRI_DIR, 'ORIGIN'))
	#	o = origin_file.read()
	#	return o

	def fetch(self, optlist=None, repos=None):
		if repos is None:
			repos = self.repos
		else:
			#TODO: turn list of strings into repos
			pass

		for r in repos:
			path = os.path.abspath(os.path.join(self.dir, r['path']))
			print r['name']
			if git.Repo.valid_repo(path):
				repo = git.Repo(path)
				repo.fetch(r['remote'])
				repo.remote_set_head(r['remote'])

	def update(self, optlist=None, repos=None):
		if repos is None:
			repos = self.repos
		else:
			#TODO: turn list of strings into repos
			pass

		for r in repos:
			path = os.path.abspath(os.path.join(self.dir, r['path']))
			print r['name']
			gitri_branch = 'gitri/%s/%s/%s' % (self.revset(), r['remote'], r['revision'])
			bookmark_branch = 'refs/bookmarks/%s/%s/%s' % (self.revset(), r['remote'], r['revision'])

			if git.Repo.valid_repo(path):
				repo = git.Repo(path)
				repo.fetch(r['remote'])
				repo.remote_set_head(r['remote'])
				remote_branch = '%s/%s' % (r['remote'], r.get('revision', 'HEAD'))
				#Make sure we're on the right branch
				if repo.head() != gitri_branch:
					print '%s has changed branches and cannot be safely updated. Skipping this repo.' % r['name']
				#Check if there are no changes
				elif repo.rev_parse(repo.head()) == repo.rev_parse(remote_branch):
					print 'no remote changes, no local changes'
				#Fast-Forward if we can
				elif repo.can_fastforward(remote_branch):
					print 'fast-forward'
					repo.merge(remote_branch)
					repo.update_ref(bookmark_branch, 'HEAD')
				#otherwise rebase local work
				elif repo.is_descendant(bookmark_branch):
					if repo.dirty():
						#TODO: option to stash, rebase, then reapply?
						print '%s has local changes and cannot be rebased. Skipping this repo.' % r['name']
					else:
						print 'rebase'
						repo.rebase(bookmark_branch, onto=remote_branch)
						repo.update_ref(bookmark_branch, remote_branch)
			else:
				url = self.remotes[r['remote']]['fetch'] + '/' + r['name']
				if r.has_key('revision'):
					repo = git.Repo.clone(url, dir=path, remote=r['remote'], rev=r['revision'], local_branch=gitri_branch)
				else:
					#TODO: this shouldn't work right now, as it would error above where gitri_branch is set
					#we need to grab the name of the branch here, and reset gitri_branch
					repo = git.Repo.clone(url, dir=path, remote=r['remote'], local_branch=gitri_branch)
				repo.update_ref(bookmark_branch, 'HEAD')

	#TODO: define precisely what this should do
	#def reset(self, optlist=[], repos=None):
	#	if repos is None:
	#		repos = self.repos
	#	gitri_branch = 'gitri/%s/%s' % (self.origin(), self.revset())
	#
	#	if optlist.has_key('soft'):
	#		mode = git.Repo.SOFT
	#	elif optlist.has_key('mixed'):
	#		mode = git.Repo.MIXED
	#	elif optlist.has_key('hard'):
	#		mode = git.Repo.HARD
	#	
	#	for r in repos:
	#		r.checkout(gitri_branch, mode = mode)

gitri_commands = {
	'init': (Project.init, False, 'o:'),
	'fetch': (Project.fetch, True, ''),
	'update': (Project.update, True, ''),
	#'reset': (Project.reset, True, ['soft', 'mixed', 'hard']),
	}

if __name__ == '__main__':
	main()

#The following code was necessary before manual clone was implemented in order to
#clone into a non-empty directory
#if os.path.exists(path) and (not os.path.isdir(path)):
#	GitriError('path %s already exists and is not a directory' % (path,))
#elif os.path.isdir(path) and (os.listdir(path) != []):
#	tmp_path = tempfile(dir='.')
#	#todo: proper path join (detect foreign OS)
#	repo = git.Repo.clone(self.remotes[p['remote']]['fetch'] + '/' + p['name'], tmp_path)
#	#move tmp_path to path
#	#rmdir tmp_path
#else:
#	#path is an empty directory, or doesn't exist
#	#todo: proper path join (detect foreign OS)
